# -*- coding: utf-8 -*-
"""Simulacion de un sistema de linea de espera.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/Medetl/Simulacion/blob/87d624013e456f67e670fd3850a7600913e87eae/Unidad%20IV/Simulacion%20de%20un%20sistema%20de%20linea%20de%20espera.ipynb

# Líneas de espera

Un sistema de colas puede describirse como: “clientes” que llegan buscando un servicio,
esperan si este no es inmediato y abandonan el sistema una vez atendidos. En algunos casos
se puede admitir que los clientes abandonan el sistema si se cansan de esperar.

![cola](https://i.imgur.com/3SFzirr.jpg)

### Características básicas:

* Patrón de llegada de los clientes
* Patrón de servicio de los servidores
* Disciplina de cola
* Capacidad del sistema
* Número de canales de servicio
* Número de etapas de servicio

Aveces se incluyen una séptima característica: la población de posibles clientes.

#### Patrón de llegada

En situaciones la llegada depende de cierta variable aleatoria. En este caso es necesario conocer la distribución probabilística entre dos llegadas de cliente sucesivas. Además habría que tener en cuenta si los clientes llegan independiente o simultáneamente. En este segundo caso (es decir, si llegan lotes) habría que definir la distribución
probabilística de éstos.

También es posible considerar clientes "impacientes", que lleguen a la cola y si es demasiado larga se vayan, o que tras esperar mucho rato en la cola decidan abandonar.

Es posible también que el patrón de llegada varíe con el tiempo. Si se mantiene constante se llama **estacionario**, si por ejemplo varía con las horas del día es **no-estacionario**.

#### Patrones de servicio de los servidores

Los servidores pueden tener un tiempo de servicio variable, para definirlo hay que asociarle una función de probabilidad. También pueden atender en lotes o de modo individual.

El tiempo de servicio también puede variar con el número de clientes en la cola, trabajando más rápido o más lento, y en este caso se llama patrones de servicio dependientes. Al igual que el patrón de llegadas, el patrón de servicio puede ser no-estacionario, variando con el tiempo transcurrido.

#### Disciplina de cola

Es la manera en que los clientes se ordenan en el momento de ser servidos. Cuando se piensa en colas se admite que la disciplina de cola normal es **FIFO** (atender primero a quien llegó primero). Sin embargo en muchas colas es habitual el uso de la disciplina **LIFO** (atender primero al último). También es posible encontrar reglas de secuencia con
prioridades, como por ejemplo secuenciar primero las tareas con menor duración o según tipos de clientes.

En cualquier caso dos son las situaciones generales en las que trabajar. En la primera, llamada
en inglés “preemptive”, si un cliente llega a la cola con una orden de prioridad superior al cliente que
está siendo atendido, este se retira dando paso al más importante. Dos nuevos subcasos aparecen: el
cliente retirado ha de volver a empezar, o el cliente retorna donde se había quedado. La segunda
situación es la denominada “no-preemptive” donde el cliente con mayor prioridad espera a que acabe
el que está siendo atendido.

#### Capacidad del sistema

En algunos sistemas existe una limitación respecto al número de clientes que pueden esperar en la cola. 
A estos casos se les denomina situaciones de cola finitas. Esta limitación puede ser considerada como 
una simplificación en la modelización de la impaciencia de los clientes.

#### Canales del servicio

Es evidente que es preferible utilizar sistemas multiservidos con una única línea de espera para
todos que con una cola por servidor. Por tanto, cuando se habla de canales de servicio paralelos, se
habla generalmente de una cola que alimenta a varios servidores mientras que el caso de colas
independientes se asemeja a múltiples sistemas con sólo un servidor.

#### Etapas de servicio

Un sistema de colas puede ser unietapa o multietapa. En los sistemas multietapa el cliente
puede pasar por un número de etapas mayor que uno. Una peluquería es un sistema unietapa, salvo
que haya diferentes servicios (manicura, maquillaje) y cada uno de estos servicios sea desarrollado por
un servidor diferente.
En algunos sistemas multietapa se puede admitir la vuelta atrás o “reciclado”, esto es habitual
en sistemas productivos como controles de calidad y reprocesos.

![cola](http://2.bp.blogspot.com/-SOVrqaCruMA/Ub0OdY2zXLI/AAAAAAAAABE/JE7JTCMJaWU/s1600/32136.png)

### Notación básica

#### Nomenclatura

* $\lambda$: Número de llegadas por unidad de tiempo.
* $\mu$: Número de servicios por unidad de tiempo si el servidor está ocupado.
* $c$: Número de servidores en paralelo.
* $\rho = \frac{\lambda}{c \mu}$: congestión del sistema.
* $N(t)$: Número de clientes en el sistema en el instante t.
* $N_q(t)$: Número de clientes en la cola en en el instante t.
* $N_q(t)$: Número de clientes en la cola en en el instante t.
* $N_s(t)$: Número de clientes en servicio en el instante t.
* $P_n(t)$: Probabilidad que haya $n$ clientes en el sistema en el instante $t=Pr{N(t)=n}$.
* $N$: Número de clientes en el sistema en el estado estable.
* $P_n$ : Probabilidad de que haya $n$ clientes en estado estable $P_n=Pr{N=n}$.
* $L$ : Número medio de clientes en el sistema.
* $L_q$ : Número medio de clientes en la cola.
* $T_q$ : Representa el tiempo que un cliente invierte en la cola.
* $S$ : Representa el tiempo de servicio.
* $T = T_q+S$: Representa el tiempo total que un cliente invierte en el sistema.
* $W_q= E[Tq]$: Tiempo medio de espera de los clientes en la cola.
* $W=E[T]$: Tiempo medio de estancia de los clientes en el sistema.
* $r$: número medio de clientes que se atienden por término medio.
* $P_b$: probabilidad de que cualquier servidor esté ocupado.

Con el tiempo se ha adoptado una notación para representar los problemas de colas
que consta de 5 símbolos separados por barras.

$$ A / B / X / Y / Z $$

A: indica la distribución de tiempo entre llegadas consecutivas

B: alude al patrón de servicio de servidores

X: es el número de canales de servicio

Y: es la restricción en la capacidad del sistema

Z: es la disciplina de cola

Los símbolos más utilizados son:

#### Distribución de tiempos de llegada (A) y de servicio (B) 

|       **Símbolo**       |    **Explicación**   |
|-------------------------|----------------------|
|             M           |      Exponencial     |
|             D           |      Determinista    |
|           $E_k$         |      Erlang          |
|             G           |      General         ||

#### Número de servidores

1, 2, 3, ... $\infty$

#### Disciplina de cola

|       **Símbolo**       |            **Explicación**          |
|-------------------------|-------------------------------------|
|      **FIFO**           |    Servir al primero que llega      |
|      **LIFO**           | Servir primero al último que llega  |
|      **RSS**            |  Selección aleatoria de servicio    |
|      **PR**             |               Prioridad             |
|      **GD**             |           Disciplina general        ||

Si no existe restricción de capacidad (Y = $\infty$) y la política de servicio es FIFO, no se suelen
incorporar dichos símbolos en la notación así:

**M/D/3** es equivalente a **M/D/3/$\infty$/FIFO**

y significa que los clientes entran según una distribución exponencial, se sirven de manera
determinista con tres servidores sin limitación de capacidad en el sistema y siguiendo una estrategia
FIFO de servicio.

#### Rendimiento de un sistema

La tarea de un analista puede ser de dos tipo:

* Establecer mecanismos para medir la efectividad del sistema 
* Diseñar un sistema “óptimo” (de acuerdo a algún criterio)

Diseñar eficientemente consiste, básicamente, en definir un sistema cuyo coste (de diseño y operación) se justifique por el servicio brindado. Dicho servicio se puede evaluar mediante el coste de “no darlo”. De este modo al diseñar se pretende minimizar unos supuestos costes totales.

A partir de los datos que nos suministra la teoría de colas se puede obtener la información necesaria para definir el número de asientos necesarios en una sala de espera, o la estructura de etapas de un proceso de atención al cliente.

### Resultados generales

resultados y relaciones para problemas G/G/1 o G/G/c.

Si $\rho \leq 1$ el sistema tenderá a crecer inexorablemente.

El número de clientes en el instante $t$, $n(t)$, es el número de llegadas que han ocurrido hasta $t$
menos el número de servicios completados hasta $t$.

El número medio de clientes en el sistema y en la cola se puede calcular de diferentes maneras: 

$$ L=E[n]= \sum_{n=0}^{\infty} n*p_n $$

$$ L_q=E[n_q]= \sum_{n=c+1}^{\infty} (n-c)*p_n $$

La famosa **fórmula de Little** establece una relación entre la longitud de la cola y el tiempo de espera:

$$  L = \lambda W  $$
     
$$  L_q = \lambda W_q  $$

El tiempo de estancia de un cliente en el sistema se relaciona con el tiempo de espera de un
cliente en la cola:

$$  W = W_q + \frac{1}{\mu} $$

El número de clientes que por término medio se están atendiendo en cualquier momento es:

$$  r = L - L_q = \lambda (W - W_q) = \frac{\lambda}{\mu}  $$

En un sistema de un único servidor:

$$ L - L_q = \sum_{n=0}^{\infty} n \cdot p_n - \sum_{n=0}^{\infty} (n-1) \cdot p_n = \sum_{n=0}^{\infty} p_n = 1 - p_0$$

La probabilidad de que un sistema de un único servidor esté vacío es $p_0 = 1 - \rho$

La probabilidad de que un servidor (de un sistema de $c$ servidores en paralelo) esté ocupado en
el estado estable es:

$$ p_b = \rho = \frac{\lambda}{c \cdot \mu}  $$

#### Ejercicio: Simulación manual. (100322)

1. Completar la tabla.

| Pkt No. |Tpll  |tps  |Tiempo de arribo|Inicio de servicio|Hora de salida|Tiempo en fila |Tiempo en el sistema  |
|---------|-----|----|--------------|-------------------|----------------|---------------|-----------------| 
|    1    |  2  | 12 |       2      |         2         |      14        |      0        |       12        |
|    2    |  5  | 10 |       7      |         14        |      24        |      7        |       17                   | 
|    3    |  1  | 16 |       8        |         24        |      40        |      16       |       32            |
|    4    |  4  | 9  |     12         |         40        |       49     |   28      |   37            |           |
|    5    |  1  | 10 |     13         |        49           |      59          |    36           |   46              | 
|    6    |  3  | 13 |      16        |          59         |       72         |    43           |     56            |
|    7    |  3  | 17 |       19       |        72           |      89          |    53           |       70          | 
|    8    |  2  | 10 |     21         |       89            |         99       |    68           |         78        |
|    9    |  4  | 8  |       25       |        99           |         107       |    74           |           82      |
|   10    |  5  | 12 |     30         |        107          |     119           |    77           |             89    |

#### Ejercicio: Continuación ... (170322)

1. Agregar dos columnas a la tabla anterior: Tamaño de la cola despues de $t$ Clientes en el sistema después de $t$.
2. Con la información de la tabla completa, determinar: $\lambda$, $\mu$, $L$ y $L_q$.

| Pkt No. |Tpll  |tps  |Tiempo de arribo|Inicio de servicio|Hora de salida|Tiempo en fila |Tiempo en el sistema  |Tamaño de la cola|Clientes es el sistema despues|
|---------|-----|----|--------------|-------------------|----------------|---------------|-----------------|----------|----------
|    1    |  2  | 12 |       2      |         2         |      14        |      0        |       12        | 5|4
|    2    |  5  | 10 |       7      |         14        |      24        |      7        |       17 |7|6              | 
|    3    |  1  | 16 |       8        |         24        |      40        |      16       |       32     |8|7       |
|    4    |  4  | 9  |     12         |         40        |       49     |   28      |   37            |        7|6|   |
|    5    |  1  | 10 |     13         |        49           |      59          |    36           |   46              |6|5 
|    6    |  3  | 13 |      16        |          59         |       72         |    43           |     56            |5|4
|    7    |  3  | 17 |       19       |        72           |      89          |    53           |       70          | 4|3
|    8    |  2  | 10 |     21         |       89            |         99       |    68           |         78        |3|2
|    9    |  4  | 8  |       25       |        99           |         107       |    74           |           82      |2|1
|   10    |  5  | 12 |     30         |        107          |     119           |    77           |             89    |1|0

# Calculando

$\lambda=\frac{10}{30}=\frac{1}{3}=0.3333$ clientes por minuto

$\mu=\frac{10}{119-2}=\frac{10}{117}=0.08547$ servicio

$L=\frac{5+7+8+7+6+5+4+3+2+1}{10}*\frac{1}{3}=\frac{48}{10}*\frac{1}{3}=\frac{8}{5}=1.6$

$L_q=\frac{4+6+7+6+5+4+3+2+1}{10}*\frac{1}{3}=\frac{19}{5}*\frac{1}{3}=\frac{19}{15}=1.26666$

### Tarea

|  Cliente i:                       |  1 | 2 | 3 |4 |5 |6 |7 |8 |9 |10 | 11 | 12 |
|-----------------------------------|----|---|---|--|--|--|--|--|--|---|----|----|
|Tiempo de llegada entre i + 1 e i: |2   | 1 | 3 |1 |1 | 4|2 |5 |1 | 2 | 2  |    |
|Tiempo de servicio al cliente:     | 1  | 3 | 6 |2 |1 | 1|4 | 2|5 |1  | 1  | 3  |

1. Contruir la tabla completa

| t | Entrada/salida i| Ini serv i | Ter serv i |T en cola |T en sist | Tamaño de cola t |Clientes en el sistema hasta t|
|---|-----------------|------------|------------|----------|----------|------------------|------------------------------|
|2|1E|1|-|0|0|0|1|
|3|1S|-|1|1|1|0|1|
|3|2E|2|-|-|-|0|1|
|6|2S|-|2|0|3|0|1|
|6|3E|3|-|-|-|0|1|
|7|4E|-|-|5|5|1|2|
|8|5E|-|-|6|6|2|3|
|12|3S|-|3|0|6|2|3|
|12|6E|4|-|-|-|2|3|
|14|4S|-|4|5|7|2|3|
|14|7E|5|-|-|-|2|3|
|15|5S|6|5|6|7|1|2|
|16|6S|7|6|3|4|0|1|
|19|8E|-|-|-|-|1|2|
|20|7S|-|7|2|6|1|2|
|20|9E|8|-|-|-|1|2|
|22|8S|-|8|1|3|1|2|
|22|10E|9|-|-|-|1|2|
|24|11E|-|-|-|-|2|3|
|27|9S|10|9|5|7|1|2|
|28|10S|11|10|1|6|0|1|
|29|11S|-|11|1|5|0|0|

# Calculando

$\lambda=\frac{11}{24}=0.45833$ clientes por minuto

$\mu=\frac{11}{29-2}=\frac{11}{27}=0.4074$ servicio

$L=\frac{20}{11}*\frac{11}{24}=\frac{5}{6}=0.8333$

$L_q=\frac{41}{11}*\frac{11}{24}=\frac{41}{24}=1.70833$

### Para construir la simulación

#### Variables:

1. Variable de tiempo $t$: tiempo (simulado) transcurrido.

2. Variables de conteo: número de veces que ciertos eventos han ocurrido, hasta el instante $t$.
    
3. Variables de estado del sistema (ES): Describen el estado del sistema en el instante $t$.

Subrutina para generar $T_s$, el tiempo de la primera llegada después del instante s.

Paso 1: Sea $t = s$.

Paso 2: Generar $U$.

Paso 3: Sea $t = t - \frac{1}{\lambda} logU$.

Paso 4: Generar $U$.

Paso 5: Si $U \leq \frac{\lambda(t)}{\lambda}$, hacer $T_s = t$ y terminar.

Paso 6: Ir al paso 2.

### Ejercicio (080322):

1. Escribir el código para la subrutina que genera $T_s$.
"""

from random import expovariate
#este codigo genera llegadas y las cuenta 
tpll=2.0    #tiempo promedio de llegada 
t=0         #tiempo 
N=0         #conteo de llegadas 
tt=15.0     #tiempo total

while t<tt:
  N=N+1                         #llegadas 
  t=t+expovariate(1.0/tpll)     #avance del tiempo  

print("clientes",N,"tiempo total",t)

from random import expovariate
from matplotlib.pyplot import *
from random import seed

tpll = 2.0             # Tiempo promedio entre llegadas
T = 15                 # Tiempo total de la simulación

N = 0                  # Variable de estado: número de llegadas

t = 0                  # Hora de simulación actual


while t <= T:
    N = N + 1
    # Avance del tiempo simulado
    t = t + expovariate(1/tpll)

print('Número total de llegadas = ', N)

"""### Extraemos los datos del código anterior"""

tpll = 2.0             # Tiempo promedio entre llegadas
T = 15                 # Tiempo total de la simulación

N = 0                  # Variable de estado: número de llegadas

t = 0                  # Hora de simulación actual

while t <= T:
    N = N + 1
    # Avance del tiempo simulado
    t = t + expovariate(1/tpll)

print('Número total de llegadas = ', N)

"""### Línea de espera con un servidor.

Se requieren las siguientes variables:

1. Variable de tiempo: $t$.

2. Variables de conteo: 

$N_A$: tiempo de llegadas hasta $t$.
                        
$N_D$: número de salidas hasta $t$.

3. Variables de estado del sistema:  $n$: número de clientes en el sistema en el instante $t$.

Lista de eventos: $t_A, t_D$, llegadas y salidas.

### Inicialización:

Sea $t = N_A = N_D = 0$.

Sea ES = 0.

Generar $T_0$ y hacer $t_A = T_0, t_D = \infty$

### Tarea: Codificar inicialización y casos (pp. 89-91)
"""

from math import inf as Infinity
tpll = 2.0                      # Tiempo de inter arrivo promedio
tps = 1.0                       # Tiempo de servicio promedio
T = 100.0                       # Tiempo total de la simulación
t = 0.0                         # Tiempo de simulación actual

N = 0                           # Variable de estado: número de clientes en el sistema

# Hora de arrivo del siguiente evento

T_arrivo = expovariate(1.0/tpll)

# Hora del próximo evento de salida

T_salida = Infinity

while t <= T:
    if T_arrivo < T_salida:                                  # Evento de arrivo
        t = T_arrivo
        N = N + 1.0
        T_arrivo = t + expovariate(1.0/tpll)
        if N == 1:
            T_salida = t + expovariate(1.0/tps)
    else:                                                    # Evento de salida
        t = T_salida
        N = N - 1.0
        if N > 0:
            T_salida = t + expovariate(1.0/tps)
        else:
            T_salida = Infinity

"""## Construyendo el código para simular la línea de espera...

El tiempo entre arrivos sigue una distribución exponencial, por lo cual multiples llegadas integran un proceso de Poisson.
"""

from random import expovariate
from matplotlib.pyplot import *
from random import seed
from math import inf as Infinity
from statistics import mean

tpll = 2.0             # Tiempo promedio entre llegadas
T = 15                 # Tiempo total de la simulación

N = 0                  # Variable de estado: número de llegadas

t = 0                  # Hora de simulación actual

llegadas = []
num = []

while t <= T:
    N = N + 1
    # Avance del tiempo simulado
    t = t + expovariate(1/tpll)
    llegadas.append(t)
    num.append(N)
    
step(llegadas, num)
print('Número total de llegadas = ', N)

"""El proceso de Poisson es un caso especial de otro tipo de proceso aleatorio, llamado de Nacimiento-Muerte."""

tpll = 2.0                      # Tiempo de inter arrivo promedio
tps = 1.0                       # Tiempo de servicio promedio
T = 100.0                       # Tiempo total de la simulación
t = 0.0                         # Tiempo de simulación actual

N = 0                           # Variable de estado: número de clientes en el sistema

# Hora de arrivo del siguiente evento

T_arrivo = expovariate(1.0/tpll)

# Hora del próximo evento de salida

T_salida = Infinity

X = []
Y = []

while t <= T:
    tll = expovariate(1.0/tpll)
    ts = expovariate(1.0/tps)
    if tll < ts:
        N += 1
        t = t + tll
        X.append(t)
        Y.append(N)
    
    else:
        if N > 0:
            N -= 1
            t = t + ts
            X.append(t)
            Y.append(N)

fig = figure(1, figsize=(16, 8))
step(X, Y, Linewidth=1.2, color='black')
xlabel('Tiempo', size=16)
ylabel('N', size=16)
show()

tpll = 2.0                      # Tiempo de inter arrivo promedio
tps = 1.0                       # Tiempo de servicio promedio
T = 100.0                       # Tiempo total de la simulación
t = 0.0                         # Tiempo de simulación actual

N = 0                           # Variable de estado: número de clientes en el sistema

# Hora de arrivo del siguiente evento

T_arrivo = expovariate(1.0/tpll)

# Hora del próximo evento de salida

T_salida = Infinity

while t <= T:
    if T_arrivo < T_salida:                                  # Evento de arrivo
        t = T_arrivo
        N = N + 1.0
        T_arrivo = t + expovariate(1.0/tpll)
        if N == 1:
            T_salida = t + expovariate(1.0/tps)
    else:                                                    # Evento de salida
        t = T_salida
        N = N - 1.0
        if N > 0:
            T_salida = t + expovariate(1.0/tps)
        else:
            T_salida = Infinity

print('Número total de llegadas = ', N)

"""## Recolección de datos de la simulación

El **rendimiento**, $\tau$, de cuántos paquetes puede procesar el sistema en una unidad de tiempo; se define como la razón del número de salidas, $D$, dividido entre el tiempo total de la simulación. $T$.

$$ \tau = \frac{D}{T} $$

Se mide en paquetes/clientes por unidad de tiempo.

La **utilización** es la proporción del tiempo de simulación durante el cual el servidor estuvo ocupado. Esto es el producto del rendimiento y el tiempo promedio de ervicio por cliente/paquete.

$$ U = \tau T_s $$

donde $T_s$ es el tiempo de servicio promedio por cliente/paquete:

$$ T_s = \frac{B}{D} $$

donde $B$ es tiempo totl en que el servidor estuvo ocupado:

$$ B = \sum_{i=1}^D T_i$$

donde $T_i$ es el tiempo de servicio del cliente/paquete $i$.

El **tiempo de respuesta** o **retraso** es el tiempo total que un cliente/paquete pasa en el sistema; incluye el tiempo de espera (tiempo en la cola) y el tiempo de servicio.

Si $W_i$ es el tiempo pasado en el sistema por el i-esimo cliente/paquete simulado, entonces el tiempo de respuesta promedio del sistema es:

$$ W = \frac{\sum_{i=1}^D W_i}{D} $$

Así, el número promedio de paquetes en el sistema puede ser calculado como:

$$ L=\tau \cdot W $$

### Estimación del tiempo promedio de respuesta del sistema
"""

from random import expovariate
from statistics import mean 
from math import inf as Infinity

# Parametros

lamda = 1.3                         # Razón de arrivos (1/Lambda)  Ojo
mu = 2.0                            # Razón de salida (1/Mu)       Ojo


Num_Pkts = 100                   # Numero de paquetes a simular
#T = 100000
count = 0                           # Contador de paquetes simulados
t = 0
N = 0                               # Variable de estado: numero de paquetes en el sistema

tll = expovariate(lamda)            # Tiempo de llegada
ts = Infinity                       # Tiempo de salida

# Variables de salida
tll_Data = []                       # Lista de tiempos de llegada
ts_Data = []                        # Lista de tiempos de salida
r_Data = []                         # Lista de retrasos individuales
paquete = []                        #lista de paquetes 

while count < Num_Pkts:
#while t < T:
    if tll < ts:                           # Evento de llegada
        t = tll
        N = N + 1.0
        tll = t + expovariate(lamda) 
        tll_Data.append(t)
        if N == 1:
            ts = t + expovariate(mu)
    else:                                         # Evento de salida
        t = ts 
        ts_Data.append(t)
        N = N - 1.0
        count = count + 1
        paquete.append(count)                         # Paquetes simulados
        if N > 0:
            ts = t + expovariate(mu)
        else:
            ts = Infinity
            
# Estimación del retraso promedio:

for i in range(Num_Pkts):
#for i in range(T):
    d = ts_Data[i] - tll_Data[i]
    r_Data.append(d)

print( "Retraso promedio = ", round( mean(r_Data), 4) )

"""### Tarea: Graficar los datos de salida del código anterior"""

from matplotlib import pyplot as plt
fig = figure(1, figsize=(16, 8))
step(paquete, r_Data, Linewidth=1.2, color='black')
xlabel('paquete', size=16)
ylabel('retraso', size=16)
plt.axhline(y=round( mean(r_Data), 4), xmin=0.01, xmax=100) #linea que grafica el retraso promedio
plt.grid()
plt.show()

"""### Estamación del número promedio de clientes en el sistema

La variable de estado $N(t)$ representa el número de clientes/paquetes en el sistema al tiempo $t$, también designado con $L$ (verificar). Esta cantidad se puede calcular directamente como:

$$\mathbb{E}[N(t)] = \frac{1}{T}\int_0^T N(t) dt $$

donde $T$ es el tiempo total de la simulación. Esta integral se puede interpretar geometricamente como el área de los escalones en la gráfica $N(t)$ vs $t$.
"""

# Parametros

lamda = 4.0                         # Razón de arrivos (1/Lambda)  Ojo
mu = 6.0                            # Razón de salida (1/Mu)       Ojo


Num_Pkts = 100000                   # Numero de paquetes a simular
#T = 100000
count = 0                           # Contador de paquetes simulados
t = 0
N = 0                               # Variable de estado: numero de paquetes en el sistema

tll = expovariate(lamda)            # Tiempo de llegada
ts = Infinity                       # Tiempo de salida

t_evento_anterior = 0.0             # tiempo del último evento ****************Nuevas líneas de código***********


# Variables de salida
tll_Data = []                       # Lista de tiempos de llegada
ts_Data = []                        # Lista de tiempos de salida
r_Data = []                         # Lista de retrasos individuales
Area = []                           # Area de escalón ***********************************************************


while count < Num_Pkts:
#while t < T:
    if tll < ts:                           # Evento de llegada
        t = tll
        tll_Data.append(t)
        
        # Area del escalón ***********************************************************************************
        Area.append((t - t_evento_anterior)*N)
        t_evento_anterior = t
        
        
        N = N + 1.0
        tll = t + expovariate(lamda) 
        if N == 1:
            ts = t + expovariate(mu)
    else:                                         # Evento de salida
        t = ts
        ts_Data.append(t)
        
        # Area del escalón ***********************************************************************************
        Area.append((t - t_evento_anterior)*N)
        t_evento_anterior = t
        
        
        N = N - 1.0
        count = count + 1                         # Paquetes simulados
        if N > 0:
            ts = t + expovariate(mu)
        else:
            ts = Infinity
            
# Estimación del retraso promedio:

for i in range(Num_Pkts):
#for i in range(T):
    d = ts_Data[i] - tll_Data[i]
    r_Data.append(d)

print( "Retraso promedio = W = ", round( mean(r_Data), 4) )
print( "E[ N(t)] = L = ", round(sum(Area)/t, 4))

"""### Ejemplo:

Lavado Automata para automóviles funciona sólo con un lugar. Los autos llegan siguiendo
una distribución de Poisson, con 4 autos por hora, que pueden esperar en el estacionamiento de
la instalación, si el lugar de lavado está ocupado. El tiempo para lavar y limpiar un automóvil
es exponencial, con 10 minutos de promedio. Los automóviles que no se pueden estacionar en
la instalación pueden esperar en el arrollo junto al lavado. Eso quiere decir que para todo fin
práctico no hay límite del tamaño del sistema. El gerente de la instalación desea determinar el
tamaño del estacionamiento.

Para resolver este problema, hay que determinar $L_q$, pero de momento estimemos $L$ y $W$ usando la simulación.
"""

from random import expovariate
from statistics import mean 
from math import inf as Infinity

def LQ(lamda,mu):
  # Parametros
  #lamda = 4                        # Razón de arrivos (1/Lambda)  Ojo
  #mu = 6                            # Razón de salida (1/Mu)       Ojo


  Num_Pkts = 100000                   # Numero de paquetes a simular
  #T = 100000
  count = 0                           # Contador de paquetes simulados
  t = 0
  N = 0                               # Variable de estado: numero de paquetes en el sistema

  tll = expovariate(lamda)            # Tiempo de llegada
  ts = Infinity                       # Tiempo de salida

  t_evento_anterior = 0.0             # tiempo del último evento ****************Nuevas líneas de código***********


  # Variables de salida
  tll_Data = []                       # Lista de tiempos de llegada
  ts_Data = []                        # Lista de tiempos de salida
  r_Data = []                         # Lista de retrasos individuales
  Area = []                           # Area de escalón ***********************************************************


  while count < Num_Pkts:
  #while t < T:
      if tll < ts:                           # Evento de llegada
          t = tll
          tll_Data.append(t)
        
          # Area del escalón ***********************************************************************************
          Area.append((t - t_evento_anterior)*N)
          t_evento_anterior = t
        
        
          N = N + 1.0
          tll = t + expovariate(lamda) 
          if N == 1:
              ts = t + expovariate(mu)
      else:                                         # Evento de salida
          t = ts
          ts_Data.append(t)
        
          # Area del escalón ***********************************************************************************
          Area.append((t - t_evento_anterior)*N)
          t_evento_anterior = t
        
        
          N = N - 1.0
          count = count + 1                         # Paquetes simulados
          if N > 0:
              ts = t + expovariate(mu)
          else:
              ts = Infinity
            
  # Estimación del retraso promedio:

  for i in range(Num_Pkts):
  #for i in range(T):
      d = ts_Data[i] - tll_Data[i]
      r_Data.append(d)

  print( "Retraso promedio = W = ", round( mean(r_Data), 4) )
  print( "E[ N(t)] = L = ", round(sum(Area)/t, 4))
  lq=lamda*(round( mean(r_Data), 4)-(1/mu))
  print("Lq=",lq)

"""### Ejercicios:

Calcular $L_q$ para el ejemplo anterior, usando las fórmulas de arriba.
"""

LQ(4,6)

"""
En una estación con un solo servidor llegan en promedio 45 clientes por hora. Se tiene capacidad para atender 
en promedio a 60 clientes por hora. Se sabe que los clientes esperan en promedio 3 minutos en la cola.
Se solicita determinar: 
* Tiempo promedio que un cliente pasa en el sistema. 
* Número promedio de clientes en la cola. 
* Número promedio de clientes en el Sistema en un momento dado.

Use la simulación para responder y luego verifique los resultados usando las fórmulas de arriba."""

LQ(45/60.0,60/60.0)

"""Podemos determinar la probabilidad de que en cierto tiempo haya exactamente $k$ clientes/paquetes en el sistema.

$$\mathbb{P}[N=k]$$

"""

from random import expovariate
from statistics import mean
from math import inf as Infinity
from random import seed
from matplotlib.pyplot import *

# Parametros

lamda = 4.0                         # Razón de arrivos (1/Lambda)  Ojo
mu = 6.0                            # Razón de salida (1/Mu)       Ojo


Num_Pkts = 100000                   # Numero de paquetes a simular
#T = 100000
count = 0                           # Contador de paquetes simulados
t = 0
N = 0                               # Variable de estado: numero de paquetes en el sistema

tll = expovariate(lamda)            # Tiempo de llegada
ts = Infinity                       # Tiempo de salida
t_evento_anterior = 0.0             # tiempo del último evento ****************Nuevas líneas de código***********

# Variables de salida
tll_Data = []                       # Lista de tiempos de llegada
ts_Data = []                        # Lista de tiempos de salida
r_Data = []                         # Lista de retrasos individuales

Data = {}                           # Diccionario *****************************************************************

while count < Num_Pkts:
#while t < T:
    if tll < ts:                           # Evento de llegada
        t = tll
        
        # longitud del intervalo entre llegadas *********************************************************************
        delta = t - t_evento_anterior
        if N in Data: 
            Data[N] += delta
        else:
            Data[N] = delta
        t_evento_anterior = t
        
        tll_Data.append(t)
        N = N + 1.0
        tll = t + expovariate(lamda) 
        if N == 1:
            ts = t + expovariate(mu)
    else:                                         # Evento de salida
        t = ts
        
        # Longitud del intervalo de tiempo **************************************************************************
        delta = t - t_evento_anterior
        if N in Data:
            Data[N] += delta
        else:
            Data[N] = delta
        t_evento_anterior = t
        
        ts_Data.append(t)
        N = N - 1.0
        count = count + 1                         # Paquetes simulados
        if N > 0:
            ts = t + expovariate(mu)
        else:
            ts = Infinity

##################################### se procesan los datos de salida ########################################
            
# Estimación del retraso promedio:

for i in range(Num_Pkts):
#for i in range(T):
    d = ts_Data[i] - tll_Data[i]
    r_Data.append(d)

print( "Retraso promedio = ", round( mean(r_Data), 4) )

# Estimación de la probabilidad de P(N=k):
for (key, value) in Data.items():
    Data[key] = value/t

# Se verifica que la probabilidad total es 1.0

print('Suma de probabilidades =', sum(Data.values()))

# Se verifican los valores de expectación
media = 0.0

for (key, value) in Data.items():
    media = media + key*value
    print(key, round(value, 4))
print('E[N] = ', media)

"""### Tarea:

Convierta los códigos anteriores para determinar W, L y P(N=k) en una función y usela para resolver los ejercicios propuestos (más tarde por classroom)
"""

from random import expovariate
import random
from statistics import mean
from math import inf as Infinity
from random import seed
from matplotlib.pyplot import *

#aqui se define la función para el programa que calcula:
#retrazo promedio 
#numero medio de clientes en el sistema 
#las probablidades de los clientes
#a es para el catalogo
def linea_de_espera(lamda,mu,a):

  Num_Pkts = 100000                  # Numero de paquetes a simular
  #T = 100000
  count = 0                           # Contador de paquetes simulados
  t = 0
  N = 0                               # Variable de estado: numero de paquetes en el sistema

  tll = expovariate(lamda)            # Tiempo de llegada
  ts = Infinity                       # Tiempo de salida
  t_evento_anterior = 0.0             # tiempo del último evento ****************Nuevas líneas de código***********

  # Variables de salida
  tll_Data = []                       # Lista de tiempos de llegada
  ts_Data = []                        # Lista de tiempos de salida
  r_Data = []                         # Lista de retrasos individuales
  tc_Data =[]                         #Lista de tiempos en caja
  tf_Data=[]                          #lista de tiempos en fila

  Data = {}                           # Diccionario *****************************************************************

  while count < Num_Pkts:
  #while t < T:
      if tll < ts:                           # Evento de llegada
          t = tll
        
        # longitud del intervalo entre llegadas *********************************************************************
          delta = t - t_evento_anterior
          if N in Data: 
              Data[N] += delta
          else:
              Data[N] = delta
          t_evento_anterior = t
        
          tll_Data.append(t)
          N = N + 1.0
          tll = t + expovariate(lamda) 
          if N == 1:
              tc=expovariate(mu)
              ts = t + tc
              tc_Data.append(tc)
      else:                                         # Evento de salida
          t = ts
        
          # Longitud del intervalo de tiempo **************************************************************************
          delta = t - t_evento_anterior
          if N in Data:
              Data[N] += delta
          else:
              Data[N] = delta
          t_evento_anterior = t
        
          ts_Data.append(t)
          N = N - 1.0
          count = count + 1                         # Paquetes simulados
          if N > 0:
              tc=expovariate(mu)
              ts = t + tc
              tc_Data.append(tc)
          else:
              ts = Infinity

##################################### se procesan los datos de salida ########################################
          
  # Estimación de la probabilidad de P(N=k):
  for (key, value) in Data.items():
      Data[key] = value/t

  # Se verifica que la probabilidad total es 1.0

  #print('Suma de probabilidades =', sum(Data.values()))
  media = 0.0
  media2=0.0
  medial=[]
  for (key, value) in Data.items():
                                                                                # Se verifican los valores de expectación 
        media = media + key*value
        #print(key, round(value, 4))
        if (key-1)>=1:                                                          #con este if se calcula lq
          media2= media2 + (key-1.0)*value
        medial.append(value)
                                                                                #la lista medial tiene los valores de las probabilidades de la fila 

 #este es un catalogo para que puedas pedir lo que necesites desde la funcion 
 #1-retraso promedio 
 #2-numero medio de clientes en el sistema 
 #3-probabilidad de que se forme cola    
  if a==1:
      # Estimación del retraso promedio:
    for i in range(Num_Pkts):
    #for i in range(T):
        d = ts_Data[i] - tll_Data[i]            #retrazo en sistema
        d2= ts_Data[i] - tll_Data[i]-tc_Data[i] #retrazo en fila
        tf_Data.append(d2)
        r_Data.append(d)
    print( "Retraso promedio=W = ", round( mean(r_Data), 4) )
    print("Tiempo en fila=W_q=",mean(tf_Data))
  elif a==2:
    print('E[N]=L = ', media)
    print("L_q=",media2)
  else:
    print('probabilidad de que se forme cola =', sum(Data.values())-medial[0])
    print("probabilidad de que esta vacio=",medial[0])

from random import expovariate
from statistics import mean, pstdev
from math import inf as Infinity
from random import seed
from matplotlib.pyplot import *
from time import time

"""Convertimos el código para estimar el tiempo de respuesta del sistema o retraso promedio en una función mm1_W de tres parámetros, que nos devuelve el retraso promedio W. Observar que la salida es un número: el promedio de los datos guardados en r_Data."""

def mm1_W(lamda, mu, Num_Pkts):
    #Num_Pkts = 100000                   # Numero de paquetes a simular
    #T = 100000
    count = 0                           # Contador de paquetes simulados
    t = 0
    N = 0                               # Variable de estado: numero de paquetes en el sistema

    tll = expovariate(lamda)            # Tiempo de llegada
    ts = Infinity                       # Tiempo de salida

    # Variables de salida
    tll_Data = []                       # Lista de tiempos de llegada
    ts_Data = []                        # Lista de tiempos de salida
    r_Data = []                         # Lista de retrasos individuales

    while count < Num_Pkts:
    #while t < T:
        if tll < ts:                           # Evento de llegada
            t = tll
            tll_Data.append(t)
            N = N + 1.0
            tll = t + expovariate(lamda) 
            if N == 1:
                ts = t + expovariate(mu)
        else:                                         # Evento de salida
            t = ts 
            ts_Data.append(t)
            N = N - 1.0
            count = count + 1                         # Paquetes simulados
            if N > 0:
                ts = t + expovariate(mu)
            else:
                ts = Infinity

    # Estimación del retraso promedio:

    for i in range(Num_Pkts):
    #for i in range(T):
        d = ts_Data[i] - tll_Data[i]
        r_Data.append(d)

    return mean(r_Data)

"""Comprobamos que nuestro programa funciona correctamente."""

mm1_W(4.0,6.0,100)

"""Ahora podemos meter la función en un bucle y analizar visualmente la variabilidad de los resultados que se obtienen al repetir muchas veces el experimento."""

lamda = 4.0
mu = 6.0


Num_Rep = 100                       # Numero de repeticiones
Delay = []                          # Lista de resultados para el retraso promedio W 

for i in range(Num_Rep):
    seed() 
    d = mm1_W(lamda, mu,1000)
    Delay.append(d)

# Estimación del promedio de las repeticiones

fig = figure(1, figsize=(16,8))
plot(Delay, linewidth=2, label='W')
axhline(y=mean(Delay), color='red',label='W promedio')
axhline(y=mean(Delay) + pstdev(Delay), color='green')
axhline(y=mean(Delay) - pstdev(Delay), color='green')
title("Estimación de W", color = 'red')
xlabel('Número de experimentos')
ylabel('W (hrs)')
legend()
show()


print("Retraso promedio W = " , round( mean(Delay), 4) )
print("Con un error de =", round(pstdev(Delay), 4))
print("W está entre:" , round(mean(Delay) - pstdev(Delay), 4), "y", round(mean(Delay) + pstdev(Delay), 4) )

"""Surgen de manera natural algunas preguntas:

* ¿Cuántos experimentos debemos realizar antes de reportar un resultado?
* ¿De qué manera depende el resultado de los experimentos del tiempo total/número de paquetes simulados?
* ¿Cómo construir y mejorar el intervalo de confianza de nuestros resultados?

## Estado transitorio y estado estable

Usaremos la misma función mm1_W pero ahora pediremos que devuelva la lista de datos completos, no solamente la media.
"""

def mm1_W(lamda, mu, Num_Pkts):
    #Num_Pkts = 100000                   # Numero de paquetes a simular
    #T = 100000
    count = 0                           # Contador de paquetes simulados
    t = 0
    N = 0                               # Variable de estado: numero de paquetes en el sistema

    tll = expovariate(lamda)            # Tiempo de llegada
    ts = Infinity                       # Tiempo de salida

    # Variables de salida
    tll_Data = []                       # Lista de tiempos de llegada
    ts_Data = []                        # Lista de tiempos de salida
    r_Data = []                         # Lista de retrasos individuales

    while count < Num_Pkts:
    #while t < T:
        if tll < ts:                           # Evento de llegada
            t = tll
            tll_Data.append(t)
            N = N + 1.0
            tll = t + expovariate(lamda) 
            if N == 1:
                ts = t + expovariate(mu)
        else:                                         # Evento de salida
            t = ts 
            ts_Data.append(t)
            N = N - 1.0
            count = count + 1                         # Paquetes simulados
            if N > 0:
                ts = t + expovariate(mu)
            else:
                ts = Infinity

    # Estimación del retraso promedio:

    for i in range(Num_Pkts):
    #for i in range(T):
        d = ts_Data[i] - tll_Data[i]
        r_Data.append(d)

    return r_Data

"""Ahora definiremos una nueva función que ejecuté mm1_W y vaya actualizando los promedios de las salidas."""

def mm1_W_cum(lamda, mu, Num_Pkts):
    Delay = mm1_W(lamda, mu, Num_Pkts)
    Delay_Cum = []
    for i in range(Num_Pkts):
        Delay_Cum.append( sum(Delay[0:i+1])/(i+1) )

    return Delay_Cum

"""Esto nos permitirá implementar un método sencillo para determinar visulmente un punto de división entre los estados transitorio y estable.

### Método de Welch

1. Para cada variable de salida correr la simulación al menos 5 veces, cada una de tamaño $m$. 

2. Calcular el promedio $Z$ de las realizaciones del paso 1.

3. Graficar la secuencia $Z$.

4. Elija el punto de corte. En el estado estable la gráfica de $Z$ es plana.
"""

from matplotlib import pyplot as plt
lamda = 4.0
mu = 6.0

n = 10000                         # Número de clientes/paquetes simulados
R = 5                             # Número de repeticiones

Y =  np.zeros( shape = (R, n) )   # Variable de salida W

# Generamos las muestras/repeticiones
for i in range(R):
    seed()
    Y[i] = mm1_W_cum(lamda, mu, n)

# Calculamos la media
Z = []
for i in range(n):
    Z.append( sum(Y[:,i]) / R )


# Graficamos Y y Z
fig = figure(1, figsize=(12, 8))
plot(Y[0], "k--", label="Y[0]", color='blue')
plot(Y[1], "k--", label="Y[1]", color='green')
plot(Y[2], "k--", label="Y[2]", color='red')
plot(Y[3], "k--", label="Y[3]", color='magenta')
plot(Y[4], "k--", label="Y[4]", color='cyan')
plot(Z, "k", linewidth=2, label="Z")

xlabel("$n$", size=16)
ylabel("$W_{cum}$", size=16)
legend(loc='upper right', shadow=True)
show()

"""### Ejercicio (01/04/22):

Elija el punto de corte, agregue las líneas de código necesarias para graficar una línea vertical y rotular el punto de corte.
"""

from matplotlib import pyplot as plt
lamda = 4.0
mu = 6.0

n = 10000                         # Número de clientes/paquetes simulados
R = 5                             # Número de repeticiones

Y =  np.zeros( shape = (R, n) )   # Variable de salida W

# Generamos las muestras/repeticiones
for i in range(R):
    seed()
    Y[i] = mm1_W_cum(lamda, mu, n)

# Calculamos la media
Z = []
for i in range(n):
    Z.append( sum(Y[:,i]) / R )

#linea de corte 
lpt0=[]
for i in range(n-1):
  a=Z[i]-Z[i+1]
  if a>0.00014:
    lpt0.append(i)

# Graficamos Y y Z
fig = figure(1, figsize=(12, 8))
plot(Y[0], "k--", label="Y[0]", color='blue')
plot(Y[1], "k--", label="Y[1]", color='green')
plot(Y[2], "k--", label="Y[2]", color='red')
plot(Y[3], "k--", label="Y[3]", color='magenta')
plot(Y[4], "k--", label="Y[4]", color='cyan')
plot(Z, "k", linewidth=2, label="Z")
plt.axvline(x=max(lpt0), ymin=0.1, ymax=0.9, color='red')


xlabel("$n$", size=16)
ylabel("$W_{cum}$", size=16)
legend(loc='upper right', shadow=True)
show()

"""### Tarea:

Determinar los puntos de corte para la función que nos da $L$. 
"""

